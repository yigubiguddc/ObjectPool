# 对象池及其简单应用

## 对象池的基本介绍

### 什么是对象池？

简单来说，正如它的名字一样，就是一个存储被创建的对象的池子。

在需要时创建对象，在使用后放回对象池，在再次需要时从池中任取一个对重复使用。

如此循环，直到总体进程结束后把对象池中的物品共同销毁。

具体的演示图像如下：



![演示](.\picture\lReo7LQa1SODZpc.png)

主要想法就是按需分配，用多少拿多少。

### 为什么要使用对象池

首先来看一款割草游戏---《吸血鬼幸存者》

![20231010193203](.\picture\vampire.png)

这款游戏的得胜目的就是撑到30分钟，越接近这个时间，出怪的速度就越疯狂，可以看到满屏幕的伤害飘字和大量宝箱以及怪物。

众所周知，**创建对象，申请内存，会占用CPU资源**。然而CPU的资源，十分滴珍贵，如果不进行任何处理直接让别人玩，电脑CPU内存不够可能直接死机。

所以说如果这里所有的怪物、经验物品、宝箱、伤害飘字全部都按照正常的方式被生成和销毁，将会带来巨额的内存开销，因此对这种方式进行优化尤为关键。

相较于频繁地创建和销毁物体，使用对象池可以节省很多性能。



### 使用对象池的优点：

1. **减少内存分配和垃圾收集**：每次创建新的对象，都需要为其分配内存。相反，销毁对象可能会产生垃圾，这需要由垃圾收集器（Garbage Collector）进行清理。垃圾收集操作可能导致游戏的短暂卡顿，然而在程序运行过程中卡顿是令人十分恼火的。通过对象池重复使用对象，可以大大减少内存分配和垃圾收集的次数。
2. **减少初始化和销毁的开销**：对象的创建和初始化，以及销毁和资源释放，通常都需要时间和计算资源。对于复杂的对象，这些操作可能特别耗时。对象池通过重复使用对象来避免这些开销。
3. **预热和预分配**：对象池**可以在游戏开始时预先创建一定数量的对象**，这样在游戏运行时，**对象的获取会非常快速**。这可以确保在高需求场景（如战斗场景）中，**游戏性能不会受到太大影响**。
4. **减少碎片化**：频繁的内存分配和释放可能导致内存碎片化，这可能会降低内存的利用效率。对象池通过固定和重复使用内存来帮助减少碎片化。
5. **提供更好的控制**：对象池提供了对**对象生命周期的更好控制**，使开发者能够根据需要调整池的大小、预热数量等。
6. **减少资源加载的延迟**：对于需要加载外部资源的对象（如纹理、音频片段等），使用对象池可以避免在游戏运行时产生的加载延迟。



### 对象池的其他应用领域

单从刚才的游戏中里例子就可以知道对象池的应用范围非常广泛。**数据库连接**、**网络连接**、**内存分配**、**图形渲染**、**消息或事件系统**等领域都有对象池的身影。



## 对象池的具体实现（简易版）

```C#
using System.Collections.Generic;
using UnityEngine;
//namespace
namespace bronya
{
    public class ObjectPool
    {
        //instance就是ObjectPool的静态实例，同时也是唯一的实例
        private static ObjectPool instance;
        //初始化一个空的字典，键值为string，存放对象名，值则为一个队列，存放改名字对象的全部实例
        private Dictionary<string, Queue<GameObject>> objectPool = new Dictionary<string, Queue<GameObject>>();
        //单独整理一个GameObject，称之为pool
        private GameObject pool;

        public static ObjectPool Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new ObjectPool();
                }
                return instance;
            }
        }
        public GameObject GetObject(GameObject prefab)
        {
            GameObject _object;
            if (!objectPool.ContainsKey(prefab.name) || objectPool[prefab.name].Count == 0)
            {
                _object = GameObject.Instantiate(prefab);
                PushObject(_object);
                if (pool == null)
                {
                    pool = new GameObject("ObjectPool");
                }
                //寻找是否已经有相应的对象池。
                GameObject child = GameObject.Find(prefab.name + "Pool");
                //如果经过了上一步child仍然位空的话
                if (!child)
                {
                    child = new GameObject(prefab.name + "Pool");
                    child.transform.SetParent(pool.transform);
                }
                _object.transform.SetParent(pool.transform);
            }
            _object = objectPool[prefab.name].Dequeue();
            _object.SetActive(true);
            return _object;
        }

        public void PushObject(GameObject prefab)
        {
            //首先获取到已经暂时使用完毕的物品名
            string _name = prefab.name.Replace("(Clone)", string.Empty);  //实例化的物品名后面都会加上(Clone)，所以我们首先使用string.Replace 把这个换成空字符串
            if (!objectPool.ContainsKey(_name))
            {
                objectPool.Add(_name, new Queue<GameObject>()); //Dictionary contains the function "Add".
            }
            objectPool[_name].Enqueue(prefab);
            prefab.SetActive(false);
        }
        //取消激活
        public void DeactivateAllObjects()
        {
            // 遍历每个对象队列
            foreach (KeyValuePair<string, Queue<GameObject>> pair in objectPool)
            {
                // 遍历队列中的每个对象
                foreach (GameObject obj in pair.Value)
                {
                    // 将对象设置为非激活状态
                    obj.SetActive(false);
                    // 但在这个情况下，由于对象已经在队列中，所以我们不需要这么做
                }
            }
        }
    }
}
```

我们分开几段来理解这个对象池的代码，同时我们也需要明确和重新认识一些概念。

### 单例模式

```c#
//唯一的私有静态对象
private static ObjectPool instance;
private Dictionary<string, Queue<GameObject>> objectPool = new Dictionary<string, Queue<GameObject>>();
//单独整理一个GameObject，变量名pool
private GameObject pool;

public static ObjectPool Instance
{
    get
    {
       if (instance == null)
       {
            instance = new ObjectPool();
       }
       return instance;
    }
}
```

​		第一段static ObjectPool instance就是声明了一个静态对象instance。同时这也是ObjectPool的**唯一对象**，在整个项目中的要使用对象池的话都是通过这个instance实现的，但是我们并不能直接访问instance。

#### C#中的属性

这里有一个C#的特性，叫做属性：

```C#
public class MyClass
{
    private string _myProperty;
    public string MyProperty
    {
        get { return _myProperty; }
        set 
        {
            if (value != null)
                _myProperty = value;
            else
                throw new ArgumentNullException("value cannot be null");
        }
    }
}
```

比如说使用到set：

```C#
MyClass obj = new MyClass();
obj.MyProperty = "Hello, World!"; 
```

使用到get

```C#
string value = obj.MyProperty;
```

这里的private string __myProperty是真正存储数据用的，而public string MyProperty则像是一个接口，通过自动调用get和set方法来进行对_myProperty的值的修改。

关键点就是两句，**私有的对象，共有的属性**。在类外通过属性来控制具体对象的变化。

接下来看本例：

```C#
public static ObjectPool Instance
{
    get
    {
       if (instance == null)
       {
            instance = new ObjectPool();
       }
       return instance;
    }
}
```

这一段提供了一个静态属性，并且只提供get方法，所以我们在ObjectPool类的外部只能通过访问Instance来访问instance的内容，由于没有set方法，所以外界无法修改instance的值。



然后是这一句：

private Dictionary<string, Queue<GameObject>> **objectPool** = new Dictionary<string, Queue<GameObject>>();

这里是初始化一个空的字典，键值为string，存放对象名，值则为一个队列，存放改名字对象的全部实例，由于和map以及queue没有什么在用法上没有很大的区别，不做过多的说明。



### GetObject与PushObject

在讲解功能之前先用图形化的界面来解释：

![GetObject](.\picture\GetObject.png)

![Push](.\picture\Push.png)



先看按需分配。只有在角色冲刺的时候，我们按下C键，这时对Shadow有了需求，我们提前制作好Shadow的预设体，每帧不断获取，每个预设体都逐渐淡化，然后在冲刺结束后不再需要这些预设体，于是放回对象池中，取消激活。

![POOL](.\picture\POOL.png)

首先会创建一个ObjecPool，然后根据预设体的名字创建一个prefabnamePool，作为ObjectPool的子物件,同时按照需求创建prefab对象的实例，也作为prefabnamePool的子物件。

各位只需要记住这里的三个层级

- ObjectPool  对象池，一切池中物体的父级
- prefabname . pool 对象池的直接子集

- prefab  prefabname . pool的直接子集

接下来的主要任务就是去构建它们三者的关系。

#### PushObject

```C#
public void PushObject(GameObject prefab)
        {
            //首先获取到已经暂时使用完毕的物品名
            string _name = prefab.name.Replace("(Clone)", string.Empty);  //实例化的物品名后面都会加上(Clone)，所以我们首先使用string.Replace 把这个换成空字符串
            if (!objectPool.ContainsKey(_name))
            {
                objectPool.Add(_name, new Queue<GameObject>()); //Dictionary contains the function "Add".
            }
            objectPool[_name].Enqueue(prefab);
            prefab.SetActive(false);
        }
```

1. **清除对象名称的“(Clone)”部分**：

   ```c#
   string _name = prefab.name.Replace("(Clone)", string.Empty);
   ```

   当在Unity中克隆一个对象时，新对象的名称通常会在其原始名称后附加“(Clone)”。在这里，该部分被使用string.Empty来代替（空字符），以便我们使用原始的预制件名称作为字典的键。

2. **检查对象是否存在**：

   ```c#
   if (!objectPool.ContainsKey(_name))
   {
       objectPool.Add(_name, new Queue<GameObject>());
   }
   ```

   这里再次检查 `objectPool` 字典是否已有一个与 `_name` 匹配的键。如果没有，则为这个名称创建一个新的队列。

3. **将对象添加到队列**：

   ```c#
   objectPool[_name].Enqueue(prefab);
   ```

   使用 `Enqueue()` 方法(和Dequeue对应)，将对象添加到相应的队列的末尾。

4. **对象取消激活**：

   ```c#
   prefab.SetActive(false);
   ```

   当对象被返回到对象池时，将其设置为不被激活。这意味着它不会在游戏中被渲染或更新，直到它再次被从对象池中取出。



#### GetObject

```C#
  public GameObject GetObject(GameObject prefab)
        {
            GameObject _object;
            if (!objectPool.ContainsKey(prefab.name) || objectPool[prefab.name].Count == 0)
            {
                _object = GameObject.Instantiate(prefab);
                PushObject(_object);
                //创建总的ObjectPool,用来存放数据
                if (pool == null)
                {
                    pool = new GameObject("ObjectPool");
                }
                //寻找是否已经有相应的对象池。
                GameObject child = GameObject.Find(prefab.name + "Pool");
                //如果经过了上一步child仍然位空的话
                if (!child)
                {
                    child = new GameObject(prefab.name + "Pool");
                    child.transform.SetParent(pool.transform);
                }
                _object.transform.SetParent(pool.transform);
            }
            _object = objectPool[prefab.name].Dequeue();
            _object.SetActive(true);
            return _object;
        }
```

1. **检查对象是否存在**：

   ​      传入的对象是GameObject类型的prefab，也就是事先做好的物体（比如子弹、虚影等，已经为它们写好了脚本或者添加了需要的组件）。

   ```C#
   if (!objectPool.ContainsKey(prefab.name) || objectPool[prefab.name].Count == 0)
   ```

   这里检查了两件事：

   - `objectPool` 字典中是否存在一个队列，其键是 `prefab.name`。
   - 如果存在这样的队列，是否有任何对象在其中（即队列是否为空）。

   

   ​	如果进入了if判断，说明目前字典中**没有**这个预设体的队列。于是先使用:_object = GameObject.Instantiate(prefab)来创建一个实例。下一步使用了PushObject，将对象推入池中。接下来进行pool是否为空的判断，这里的pool就是总的父组件。如果为空就直接创建一个，命名为ObjectPool。

   ​	下一步是在列表中查找是否有prefab.name + "Pool"为名字的物体，如果没有，依旧是直接创建，然后设为刚才的ObjectPool的子物体。

   ​	最后的_object.transform.SetParent(pool.transform);就是把预设体的父物体设为刚才创建的prefabname+"Pool"，到此就完成了一个对象池的基本结构的搭建。

2. **从队列中取出对象**：

   ```c#
   _object = objectPool[prefab.name].Dequeue();
   ```

   如果存在相应的队列，并且它不为空，那么从队列的前端取出一个对象。`Dequeue()` 方法从队列中移除并返回该对象。有的时候可能感觉这个队列是不是一直为空？因为我在GetObject中调用了PushObject，先Enqueue之后再Dequeue。在通过GetObject获取一个物体时确实如此，**但是我们在不使用这个物体时一定要执行一次PushObject，这个时候就只有Enqueue**，那么队列就不为空，同时在Unity的窗口中仍然可以看到被取消激活的gameObject物体。（马上介绍gameObject和GameObject）



1. **激活对象**：

   ```C#
   _object.SetActive(true);
   ```

   从队列中取出的对象可能是不活动的（因为在返回对象池时它们被设置为不活动的），所以这里将它重新激活。

   

​		最后看到这里的返回值是GameObject类型的，在这里区分以下**GameObject**和**gameObject**。



​		GameObject是一种类名，unity中非常多的物体都是它的对象,通过声明一个GameObject类型的对象，可以改变它的诸多属性。在 Unity 中，几乎所有在场景中的对象都是 `GameObject`。



​		而gameObject相当于你已经有了这个对象（GameObject创建的对象），通过gameObject可以访问它的name（名称）、tag（标签）、layer（图层）...常用的方法有gameObject.SetActive(false);使用了这个方法之后Unity中对应的这个组件就会变灰：

![1](.\picture\1.png)

![2](.\picture\2.png)



单例模式确保在整个项目中有且仅有唯一的一个静态实例（对象），通过调用静态方法来增强数据的安全性。



# 对象池的简单应用---冲刺的残影

关于冲刺，这里写的比较简单，主要讲讲关于残影的生成。

这里首先设定按下C键后开始冲刺。

然后在dashTimeLeft > 0 的时候（这个是每次冲刺持续的时间，具体实现的思路后面有相同的地方，所以这里先不说是如何计时的），

设置动画--->判断角色朝向--->重置速度--->从对象池中获取shadow实例--->冲刺时间冷却。

if (dashTimeLeft > 0) 
            {
                _animator.SetBool(AnimatorHash.IsDashing, true);
                float direction = transform.rotation.y == 0 ? -1 : 1;
                _rigidbody.velocity = new Vector2(dashSpeed * direction, _rigidbody.velocity.y);
                ObjectPool.Instance.GetObject(shadowprefab);
                dashTimeLeft -= Time.deltaTime;
            }

```C#
//dash component
[Header("datas")]
public float dashTime;				//冲刺的持续时间，可以通过调整dashTime来调整冲刺时间
private float dashTimeLeft;
public bool isDashing;
private float lastDash = -10f;      //确保第一次Time.time一定大于lastDash+ dashCoolDown;
public float dashCoolDown;
public float dashSpeed;
//Update函数每帧执行
public void Update()
{  
    if(Input.GetKeyDown(KeyCode.C))
    {
        //本次按下C的时间大于上次冲刺时间加上冲刺冷却时间，那么可以准备这次冲刺
        if(Time.time>(lastDash +dashCoolDown))	
        {
            //按下c，开启ReadToDash函数
           ReadyToDash();
        }
     } 
}
private void ReadyToDash()
{
    isDashing = true;			//设置isDashing为true
    dashTimeLeft = dashTime;	//
    lastDash = Time.time;		//更新上次冲刺时间
}
//一般物理效果放在FixedUpdate中
private void FixedUpdate()
{
    Dash();
}
private void Dash()
{
        if(isDashing)
        {
            if (dashTimeLeft > 0) 
            {
                _animator.SetBool(AnimatorHash.IsDashing, true);
                float direction = transform.rotation.y == 0 ? -1 : 1;
                _rigidbody.velocity = new Vector2(dashSpeed * direction, _rigidbody.velocity.y);
                ObjectPool.Instance.GetObject(shadowprefab);
                dashTimeLeft -= Time.deltaTime;
            }
            if(dashTimeLeft<=0)
            {
                isDashing = false;
                _animator.SetBool(AnimatorHash.IsDashing,false);
            }
        }
}
```



## 影子的图标获取以及消失和控制

影子的每一帧都和角色动画的前一帧相同，这个也是很容易实现的。

只需要获取角色的组件，在每次影子被ObjectPool.Instance.GetObject(shadowprefab)构建的时候，

thisSprite.sprite = playerSprite.sprite;

 transform.position = player.position;

 transform.localScale = player.localScale;

 transform.rotation = player.rotation;



第一句就是sprite组件等于player的sprite（**sprite就是用来显示图片的组件**，它是Sprite Renender的一个子物体）

![](.\picture\QQ截图20231013002627.png)

最后，影子的控制，简单来讲，这个组件构建了一个抽象,关键点只有四个变量:

- public float activeTime
- public float activeStart
- public float alphaSet
- public float alphaMultipilier

分别时希望对象被激活的时间、激活开始的时间（每次）、初始亮度设置、平滑降低亮度设置。

每次shadow被需要时进行调用，同时更新activeStart = Time.time;这个时间点被记录下来，它是一个float类型的值。

接下来在Update函数（每帧执行）中不断降低alpha值（亮度）

alpha -= alphaMultiplier;

最后，

进行一个判断：

if(Time.time>activeStart + activeTime)
 {
        ObjectPool.Instance.PushObject(gameObject);
 }

这个也就很好理解了，时间到了就把对象放回池中，以便等待下一次备用。

```c#
//dash shadow component
using UnityEngine;
using bronya;	//use objectpool
public class ShadowSprite : MonoBehaviour
{
    //获取player组件
    private Transform player;
    //两个sprite，分别用来获取和显示残影
    private SpriteRenderer thisSprite;
    private SpriteRenderer playerSprite;
    //color，用来控制颜色
    private Color color;
    //激活时间
    public float activeTime;
    //激活开启时间
    public float activeStart;
    //亮度
    private float alpha;
    //初始亮度设计
    public float alphaSet;
    //平滑改变亮度值
    public float alphaMultiplier;   //smoothly change the value
    private void OnEnable()
    {
        //从列表中查询Tag为Player的组件，注意，如果有多个玩家的话可以考虑添加tag，命名为player1，player2，避免混淆
        player = GameObject.FindGameObjectWithTag("Player").transform;
        //组件获取
        thisSprite = GetComponent<SpriteRenderer>();
        playerSprite = player.GetComponent<SpriteRenderer>();
        alpha = alphaSet;
        //shadow的sprite组件就直接等于这一时刻player的sprite组件
        thisSprite.sprite = playerSprite.sprite;
        //这三步则是保证transform组件的一致性
        transform.position = player.position;
        transform.localScale = player.localScale;
        transform.rotation = player.rotation;
        //activeStart equal to Time.time
        activeStart = Time.time;
    }
    private void Update()
    {
        //每帧减少alpha的值
        alpha -= alphaMultiplier;
        //这里是随手调的颜色，可以自主选择，前三个参数就是三原色的配比，最后一个参数是亮度
        color = new Color(0.5f, 0.5f, 1, alpha);
        thisSprite.color = color;
        if(Time.time>activeStart + activeTime)
        {
            ObjectPool.Instance.PushObject(gameObject);
        }
    }
}
```







